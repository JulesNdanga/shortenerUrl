# Questions/Réponses d'entretien – Projet Raccourcisseur d'URL Laravel

## 1. Pourquoi avoir choisi cette architecture ?
- J'ai suivi la structure standard Laravel (MVC) pour garantir la maintenabilité et la clarté.
- Les modèles Eloquent facilitent la gestion des relations (ShortUrl <-> Click).
- Les contrôleurs sont séparés : un pour l'API, un pour la redirection, ce qui isole bien les responsabilités.

## 2. Pourquoi ce modèle de base de données ?
- Une table `short_urls` pour stocker le mapping, le code court, le compteur de clics, les timestamps.
- Une table `clicks` pour historiser chaque clic (utile pour analyses futures).
- Indexation sur `short_code` pour la rapidité des recherches.

## 3. Comment ajouter une nouvelle fonctionnalité (ex : expiration d'URL) ?
- (Déjà implémenté) Ajout d'une colonne `expires_at` à la table `short_urls` (migration).
- Lors de la création d'une URL courte (`POST /api/shorten`), on peut fournir `expires_at` (date d'expiration, format ISO8601 ou `YYYY-MM-DD HH:MM:SS`).
- Si la date est dépassée, la redirection est bloquée et une page d'expiration s'affiche (HTTP 410).
- Pour modifier la logique (ex : notification avant expiration, suppression automatique), il suffit d'adapter le contrôleur ou d'ajouter une tâche planifiée.

## 4. Codes courts personnalisés : fonctionnement et conception
- Le champ `custom_code` est optionnel dans la requête POST `/api/shorten`.
- Si fourni, il doit être alphanumérique (4 à 32 caractères) et unique.
- Si le code existe déjà, l'API retourne une réponse 200 (et non une erreur), avec le mapping existant et un message explicite (expérience utilisateur améliorée).
- Sinon, le code est utilisé pour l'URL courte. Si non fourni, un code aléatoire est généré automatiquement.
- Avantage : l'utilisateur peut choisir un alias mémorable, tout en étant certain de ne pas écraser un code existant.

## 5. Limitation du débit (Rate Limiting)
- Les endpoints POST `/api/shorten` et `/api/shorten/batch` sont limités à 10 requêtes/minute par IP (middleware Laravel throttle).
- Si la limite est dépassée, le serveur retourne HTTP 429 (Too Many Requests) avec un message d’erreur explicite.
- Cela protège l’API contre les abus, les scripts automatisés et garantit la disponibilité du service pour tous.

## 6. Raccourcissement en masse : côté interface utilisateur (UX)
- L'utilisateur colle plusieurs URLs dans un champ multiligne (une URL par ligne).
- Pour chaque URL, il peut saisir un code personnalisé et une date d'expiration via des champs dédiés.
- Il clique sur « Préparer les options » puis « Raccourcir toutes les URLs ».
- L'interface web (batch.html) transforme ces entrées en requête adaptée à l'API `/api/shorten/batch`.
- Les résultats sont affichés ligne par ligne dans un tableau (succès, erreurs, conflits).
- L'utilisateur n'a jamais à manipuler le format JSON : tout est automatisé côté front-end.

- L'utilisateur prépare un tableau d'URLs à raccourcir (avec éventuellement des codes personnalisés et dates d'expiration).
- Il envoie ce tableau via l'API `/api/shorten/batch` (méthode POST) :
  - Outils recommandés : Postman, Insomnia, curl, script JS, ou future interface web dédiée.
  - Exemple de payload :
    ```json
    {
      "items": [
        { "url": "https://ex1.com", "custom_code": "promo1", "expires_at": "2025-07-15 23:59:59" },
        { "url": "https://ex2.com" }
      ]
    }
    ```
- L'API retourne un tableau de résultats (succès, erreur, code déjà existant pour chaque entrée).
- UX : pour une interface graphique, prévoir un formulaire permettant d'ajouter plusieurs URLs, de visualiser les résultats ligne par ligne et d'afficher clairement les erreurs ou conflits de codes.

## 6. Comment améliorer la sécurité ?
- Valider et filtrer les URLs pour éviter les redirections malicieuses.
- Limiter le nombre de créations par IP (rate limiting).
- Ajouter une authentification si on veut gérer la propriété des liens.

## 7. Et si tu devais refaire ce projet sans connexion internet ?
1. Créer un nouveau projet Laravel (`composer create-project ...`).
2. Configurer le `.env` pour MySQL.
3. Générer les modèles et migrations (`php artisan make:model ... -m`).
4. Implémenter les contrôleurs et routes.
5. Lancer les migrations (`php artisan migrate`).
6. Tester avec Postman ou curl.

## 8. Comment prouver que tu es bien l'auteur ?
- Je peux expliquer chaque ligne de code, chaque choix d'implémentation, et détailler la logique métier.
- Je peux modifier ou ajouter une fonctionnalité en direct (ex : ajout de stats avancées, ou d'une nouvelle validation).

## 9. Améliorations ou alternatives ?
- Utiliser Redis pour le compteur de clics (scalabilité).
- Ajouter Swagger pour la documentation API.
- Ajouter des tests unitaires et d'intégration.
- Dockeriser le projet pour simplifier le déploiement.
- Ajouter l'authentification pour la gestion privée des liens.

## 11. Documentation API (Swagger/OpenAPI)
- Fichier `public/openapi.yaml` (OpenAPI 3/Swagger) décrivant toute l’API.
- Peut être ouvert dans Swagger Editor pour visualisation, test, doc interactive.
- Atout fort pour l’entretien : démontre la rigueur et la professionnalisation de l’API.

## 10. Pages protégées et Administration :
Tests automatisés (Feature/API) :
- Couverture complète des endpoints d'authentification, création de liens, historique, etc.
- Tests Laravel dans tests/Feature, base SQLite en mémoire, reset à chaque test.
- Pour permettre les tests API avec Sanctum, le middleware EnsureFrontendRequestsAreStateful est commenté dans Kernel (à réactiver en prod).
- Démarche de debug : test de routage minimal, diagnostic middleware, correction progressive jusqu'à exécution complète des tests.
- Certaines pages (raccourcissement, batch, historique) sont accessibles uniquement aux utilisateurs connectés.
- Interface d'administration (login par défaut admin@admin.com/admin123), dashboard évolutif.
- Affichage UX des messages de succès/erreur sur les formulaires.

## 11. Points de vigilance
- Gestion des collisions de codes courts.
- Validation stricte des entrées.
- Gestion des erreurs et des cas limites (404, DB down, etc.).

## 12. Questions classiques d'entretien
## 11. Questions classiques d'entretien
- "Comment garantir l'unicité et la rapidité du code court ?"
- "Pourquoi avoir séparé API et redirection ?"
- "Comment gérer la montée en charge ?"
- "Comment tester la sécurité ?"
- "Comment ajouter une fonctionnalité X ?"
- "Si tu devais tout refaire, que changerais-tu ?"

---

Ce document te permet de réviser rapidement tous les choix techniques, les points d'amélioration, et d'être prêt à répondre à la plupart des questions d'entretien sur ce projet.
